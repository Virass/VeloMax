# Технічна документація по проекту VeloMax


## Зміст

- [Технічна документація по проекту VeloMax](#технічна-документація-по-проекту-velomax)
  - [Зміст](#зміст)
    - [Як стартувати проект?](#як-стартувати-проект)
    - [Робота з API та .env](#робота-з-api-та-env)
      - [Налаштування змінних середовища](#налаштування-змінних-середовища)
      - [Важливі моменти](#важливі-моменти)
      - [Структура змінних середовища](#структура-змінних-середовища)
  - [Коміти та Pull Requests](#коміти-та-pull-requests)
    - [Коміти](#коміти)
      - [Типи комітів (type)](#типи-комітів-type)
      - [Приклади правильних комітів](#приклади-правильних-комітів)
    - [Pull Requests](#pull-requests)
    - [Про стек технологій](#про-стек-технологій)
      - [Next.js](#nextjs)
      - [Zustand](#zustand)
      - [React Hook Form](#react-hook-form)
      - [Mantine UI](#mantine-ui)
      - [FSD (Feature-Sliced Design)](#fsd-feature-sliced-design)
      - [MVC (Model-View-Controller)](#mvc-model-view-controller)
      - [Supabase](#supabase)
      - [Vercel](#vercel)
  - [Архітектурні патерни: FSD + MVC у VeloMax](#архітектурні-патерни-fsd--mvc-у-velomax)
    - [FSD (Feature-Sliced Design)](#fsd-feature-sliced-design-1)
      - [Поточна структура (спрощено):](#поточна-структура-спрощено)
      - [Принципи:](#принципи)
      - [Переваги FSD Архітектури](#переваги-fsd-архітектури)
    - [Початок Роботи з Цим Шаблоном](#початок-роботи-з-цим-шаблоном)
    - [Найкращі Практики](#найкращі-практики)
    - [MVC Паттерн в Рамках Функцій](#mvc-паттерн-в-рамках-функцій)
      - [MVC Структура в Рамках Функції](#mvc-структура-в-рамках-функції)
      - [Переваги MVC в Рамках Функцій](#переваги-mvc-в-рамках-функцій)
      - [Керівні Принципи Реалізації](#керівні-принципи-реалізації)
      - [Коли Використовувати MVC в Функціях](#коли-використовувати-mvc-в-функціях)
      - [Альтернативні Підходи для Простих Функцій](#альтернативні-підходи-для-простих-функцій)
    - [Best practices для VeloMax](#best-practices-для-velomax)
  - [Лінтинг та форматування коду](#лінтинг-та-форматування-коду)
    - [ESLint](#eslint)
    - [Prettier](#prettier)

### Як стартувати проект?
1. Клонуйте репозиторій:
  ```bash
  git clone https://github.com/Virass/VeloMax.git
  cd VeloMax
  ```
2. Встановіть залежності:
  ```bash
  npm install
  ```
3. Запустіть проект:
  ```bash
  npm run dev
  ```

### Робота з API та .env
Для роботи з API та конфігурацією проекту використовується файл `.env`, який містить змінні середовища. У цьому файлі зберігаються всі чутливі дані, такі як ключі API, URL-адреси бази даних та інші налаштування, які не повинні бути жорстко закодовані в коді.

**⚠️ КРИТИЧНО ВАЖЛИВО:** Ніколи не використовуйте дані з файлу `.env` безпосередньо в коді! Завжди отримуйте доступ до змінних середовища через `process.env.VARIABLE_NAME`. Це забезпечує безпеку та коректну роботу в різних середовищах (розробка, тестування, продакшн).

**Правильно:**
```javascript
const apiUrl = process.env.NEXT_PUBLIC_API_URL;
const dbUrl = process.env.DATABASE_URL;
```

**НЕПРАВИЛЬНО:**
```javascript
// ❌ Ніколи не робіть так!
const apiUrl = "https://api.example.com"; // жорстко закодовано
import { readFileSync } from 'fs'; // ❌ читання .env файлу напряму
```

#### Налаштування змінних середовища

1. **Створіть файл `.env`:**
  ```bash
  cp .env.example .env
  ```

2. **Заповніть необхідні змінні:**
  Відкрийте файл `.env` та вкажіть актуальні значення для всіх змінних, перелічених у `.env.example`.

3. **Отримання значень:**
  Актуальні значення змінних середовища можна отримати у технічного ліда проекту.

#### Важливі моменти

- **Безпека:** Ніколи не додавайте файл `.env` до системи контролю версій
- **Синхронізація:** При додаванні нових змінних оновлюйте файл `.env.example`
- **Документація:** Всі змінні мають бути задокументовані з описом їх призначення

#### Структура змінних середовища

Проект використовує наступні категорії змінних:
- **Supabase:** Конфігурація бази даних та автентифікації
- **Next.js:** Налаштування додатка та API routes
- **Зовнішні API:** Ключі для інтеграції з третіми сервісами

## Коміти та Pull Requests
В проекті ми не слідуємо якійсь доктрині жорстко, але намагаємося дотримуватися певних принципів для забезпечення якості коду та зручності роботи в команді.

### Коміти
- Використовуйте зрозумілі та інформативні повідомлення комітів.
- Дотримуйтеся формату: `type(scope): subject` (наприклад, `feat(auth): add login functionality`) або `type: subject` (наприклад, `fix: correct typo in auth`).


#### Типи комітів (type)
- **feat** — додавання нової функціональності
- **fix** — виправлення помилок
- **docs** — зміни в документації
- **style** — форматування коду, відступи (без змін логіки)
- **refactor** — рефакторинг коду без додавання функцій або виправлення помилок
- **chore** — зміни в налаштуваннях, залежностях, скриптах збірки


#### Приклади правильних комітів

**✅ Хороші приклади:**
```bash
feat(auth): add login functionality
fix(ui): correct button alignment on mobile
docs: update README with installation steps
refactor(api): simplify user data fetching
style: fix indentation in ProfileCard component
chore: update dependencies to latest versions
```

**❌ Неправильні приклади:**
```bash
fix error              # Занадто загально
Final fix              # Незрозуміло що виправлено
update                 # Що саме оновлено?
changes                # Які зміни?
work in progress       # Незавершена робота
```

**❗️ Важливо!** - ми не слідуємо цих правил жорстко, але намагаємося дотримуватися їх для спрощення роботи в команді.

### Pull Requests
- В Pull Request дайте короткий опис проведеної роботи
- Залиште посилання на задачу (якщо така є)
- Запросіть код-рев'ю у колег через кнопку "Request Review" (Правилом правильної практики розробки є залучення колег до перевірки коду)
- Повідомте команду про завершення роботи над Pull Request.

### Про стек технологій
- NextJs
- Zustand (global state management)
- React hook form
- Mantine UI (UI kit)
- FSD + MVC (development pattern)
- Supabase (database)
- Vercel (develop branch hosting)
- NodeJS v20+

#### Next.js
Метафреймворк для React. Обраний для спрощення розробки як готове рішення з багатьма вбудованими функціями.
Офіційна документація: [Next.js](https://nextjs.org/docs)

#### Zustand
Бібліотека для вирішення задач роботи з глобальним станом в React чи в нашому випадку з клієнтською частиною Next.js.
Офіційна документація: [Zustand](https://zustand.docs.pmnd.rs/getting-started/introduction)

#### React Hook Form
Бібліотека для роботи з формами в React. Бібліотека вже має зручний інструментарій для випадків великої кількості інпутів та валідації, обробка запитів та інше.
Офіційна документація: [React Hook Form](https://react-hook-form.com/get-started)

#### Mantine UI
Готовий UI kit для React та Next.js. Дозволить швидко створювати інтерфейси користувача з використанням готових компонентів.
Офіційна документація: [Mantine UI](https://mantine.dev/)

#### FSD (Feature-Sliced Design)
Архітектурний патерн, який дозволяє розділити проект на окремі функціональні частини, що полегшує масштабування та підтримку коду. В даному проекті FSD взято лише як основу, основні принципи будуть описані нижче.

#### MVC (Model-View-Controller)
Ще один патерн, який розділяє логіку в коді, дозволить в рамках окремо взятих функціональних частин використовувати правила для кращої організації коду. 

#### Supabase
Своєрідна альтернатива повноцінному бекенду. Це інструментарій та база даних, яка має в собі рішення для роботи з даними, автентифікації, розділення на ролі, генерації API і т.д.
Офіційна документація: [Supabase](https://supabase.com/docs)

#### Vercel
Для розгортання проекту для так званого stage будемо використовувати Vercel. Безкоштовного тарифу для розробки має бути достатньо для розгортання проекту та тестування.
Офіційний сайт: [Vercel](https://vercel.com/)



## Архітектурні патерни: FSD + MVC у VeloMax

У цьому проекті використовується адаптований під проект підхід **Feature-Sliced Design (FSD)** у поєднанні з принципами **MVC (Model-View-Controller)** для організації коду. Це дозволяє масштабувати додаток, спрощує підтримку та командну роботу.

### FSD (Feature-Sliced Design)
FSD — це організація коду за функціональністю, а не технічними шарами. Основні принципи:
- **Кожна функція — окрема директорія у `features/`** (наприклад, `admin-panel`, `website`)
- **Глобальні речі** (конфіг, провайдери, store) — у `core/`
- **Спільні компоненти, хуки, типи, стилі** — у `shared/`
- **Вся бізнес-логіка, специфічна для функції, інкапсулюється у відповідній папці**

#### Поточна структура (спрощено):
```
src/
├── app/            # Next.js app router, layout, сторінки, API-**роути**
├── core/           # Конфігурація, провайдери, глобальні store
├── features/       # Функціональні модулі (feature-oriented)
├── shared/         # Спільні компоненти, хуки, типи, стилі, іконки для повторного використання
```

#### Принципи:
- **Модульність:** Кожна функція ізольована, легко масштабувати
- **Повторне використання:** Все спільне — у shared
- **Глобальні речі:** Тільки у core
- **Жодних імпортів між features напряму** (через shared або core)

#### Переваги FSD Архітектури

**Модульність**: Чіткі межі між функціями запобігають зв'язуванню коду та роблять кодову базу легшою для розуміння.

**Масштабованість**: Нові функції можна додавати без впливу на існуючий код. Структура підтримує масштабування команди з власністю на основі функцій.

**Підтримуваність**: Логічна організація робить легким знаходження та модифікацію коду. Пов'язана функціональність знаходиться разом.

**Повторне Використання**: Спільні компоненти та утиліти усувають дублювання коду та забезпечують узгодженість.

**Типобезпека**: Інтеграція TypeScript по всій архітектурі забезпечує перевірку помилок під час компіляції та кращий досвід розробника.

**Продуктивність**: Розділення коду на основі функцій дозволяє lazy loading та оптимізовані розміри бандлів.

**Командна Співпраця**: Чіткі межі дозволяють кільком розробникам працювати над різними функціями одночасно без конфліктів.

### Початок Роботи з Цим Шаблоном

1. **Клонуйте або скопіюйте цю структуру** для вашого нового React проєкту
2. **Встановіть залежності** відповідно до потреб вашого проєкту (React Router, управління станом, UI бібліотека)
3. **Сконфігуруйте app шар** з вашими специфічними API endpoints та глобальними налаштуваннями
4. **Створіть вашу першу функцію** в директорії `/features`
5. **Налаштуйте інтернаціоналізацію** в `/locales` за потреби
6. **Кастомізуйте макети** в `/layouts` відповідно до ваших дизайнерських вимог

### Найкращі Практики

- Тримайте функції незалежними та уникайте імпортів між функціями
- Використовуйте shared шар для справді багаторазових компонентів та утиліт
- Слідуйте послідовним конвенціям найменування в усіх директоріях
- Реалізуйте правильні TypeScript типи для кращого досвіду розробки
- Використовуйте lazy loading для модулів функцій для оптимізації розміру бандлу

### MVC Паттерн в Рамках Функцій

Хоча загальна архітектура слідує Feature-Sliced Design, рекомендується реалізовувати **MVC (Model-View-Controller)** паттерн в рамках окремих функцій для кращої організації та підтримуваності.

#### MVC Структура в Рамках Функції

Для складних функцій (наприклад, auth, user profile, dashboard) рекомендується використовувати патерн MVC:
- **Model:** API-запити, типи, store, валідація
- **View:** UI-компоненти, форми, модалки
- **Controller:** Бізнес-логіка, хуки, обробники дій

```
features/
└── UserProfile/
    ├── index.ts                # Експорти публічного API
    ├── model/                  # Шар Моделі
    │   ├── types.ts           # TypeScript інтерфейси та типи
    │   ├── store.ts           # Управління станом (Zustand/Redux)
    │   ├── api.ts             # API виклики та завантаження даних
    │   └── validators.ts      # Логіка валідації даних
    ├── view/                   # Шар Представлення
    │   ├── ProfileCard.tsx    # UI компоненти
    │   ├── ProfileForm.tsx    # Компоненти форм
    │   └── ProfileModal.tsx   # Модальні компоненти
    └── controller/             # Шар Контролера
        ├── useProfile.ts      # Хуки бізнес-логіки
        ├── useProfileForm.ts  # Логіка обробки форм
        └── profileActions.ts  # Створювачі дій та обробники
```

#### Переваги MVC в Рамках Функцій

**Чітке Розділення Обов'язків**: Кожен шар має окрему відповідальність:
- **Model (Модель)**: Управління даними, API виклики, валідація, стан
- **View (Представлення)**: UI компоненти, логіка презентації
- **Controller (Контролер)**: Бізнес-логіка, взаємодія з користувачем, координація потоку даних

**Покращена Підтримуваність**: Зміни в бізнес-логіці не впливають безпосередньо на UI компоненти, і навпаки.

**Покращена Тестованість**: Кожен шар може бути протестований незалежно з mock залежностями.

**Командна Співпраця**: Різні члени команди можуть працювати над різними шарами одночасно.

**Масштабована Розробка Функцій**: Коли функції ростуть в складності, MVC структура запобігає їх перетворенню в монолітні.

#### Керівні Принципи Реалізації

1. **Шар Моделі**:
   - Тримайте всю логіку, пов'язану з даними (API виклики, управління станом, валідація)
   - Експортуйте чисті інтерфейси для споживання контролерами
   - Обробляйте трансформації даних та бізнес-правила

2. **Шар Представлення**:
   - Зосереджуйтесь виключно на презентації та користувацькому інтерфейсі
   - Отримуйте дані через props, уникайте прямого доступу до стану
   - Тримайте компоненти якомога чистішими та багаторазовими

3. **Шар Контролера**:
   - Координуйте між шарами моделі та представлення
   - Реалізуйте кастомні хуки для складної бізнес-логіки
   - Обробляйте взаємодію користувача та побічні ефекти

4. **Індекс Функції**:
   - Експортуйте лише необхідні публічні API
   - Тримайте внутрішні деталі реалізації приватними
   - Надавайте чистий інтерфейс для інших частин додатку

Цей підхід поєднує переваги FSD на макро-рівні з організацією MVC на мікро-рівні, що призводить до високо підтримуваних та масштабованих модулів функцій.

#### Коли Використовувати MVC в Функціях

**✅ Рекомендується використовувати MVC коли:**

- **Складна бізнес-логіка**: Функція містить багато бізнес-правил, валідації або складних обчислень
- **Множинні джерела даних**: Потрібно працювати з кількома API, локальним сховищем та глобальним станом
- **Складні форми**: Форми з багатьма полями, валідацією, умовною логікою та етапами
- **Великі команди**: Над функцією працюють 3+ розробники одночасно
- **Високі вимоги до тестування**: Критично важливі функції, що потребують всебічного тестування
- **Довгостроковий розвиток**: Функція буде активно розвиватися та розширюватися
- **Повторне використання логіки**: Бізнес-логіка може бути використана в інших частинах додатку

**Приклади функцій, де MVC доречний:**
```
✅ UserProfile - управління профілем, редагування, валідація
✅ PaymentProcess - складний процес оплати з множинними етапами
✅ ReportGenerator - генерація звітів з фільтрами та експортом
✅ Dashboard - складна панель з віджетами та аналітикою
```

**❌ НЕ рекомендується використовувати MVC коли:**

- **Прості UI компоненти**: Статичні компоненти без бізнес-логіки
- **Невеликі функції**: Менше 5 компонентів та мінімальна логіка
- **Швидкі прототипи**: MVP або POC проєкти з обмеженим часом
- **Одноразові функції**: Функції, які не будуть розвиватися
- **Прості CRUD операції**: Базові операції без додаткової логіки
- **Статичний контент**: Сторінки з інформацією, FAQ, документація

**Приклади функцій, де MVC буде надлишковим:**
```
❌ AboutPage - статична сторінка з інформацією про компанію
❌ LoadingSpinner - простий компонент для відображення завантаження
❌ ContactInfo - відображення контактної інформації
❌ SimpleModal - модальне вікно з базовою функціональністю
```

#### Альтернативні Підходи для Простих Функцій

Для невеликих функцій використовуйте спрощену структуру:

```
features/
└── SimpleFeature/
    ├── index.ts                # Експорти
    ├── Component.tsx           # Головний компонент
    ├── hooks.ts               # Прості хуки (якщо потрібно)
    └── types.ts               # Типи (якщо потрібно)
```

**Поступовий перехід**: Починайте з простої структури і переходьте до MVC при збільшенні складності функції.

### Best practices для VeloMax
- Додавайте нові фічі тільки у features
- Все спільне — у shared (компоненти, хуки, типи, стилі)
- Глобальні речі (auth, supabase, app-store) — у core
- Не імпортуйте напряму між features
- Дотримуйтесь єдиних правил ESLint/Prettier
- Для складних фіч використовуйте MVC усередині features

> **Рекомендація:** Починайте з простої структури, переходьте до MVC у features лише коли фіча ускладнюється.


## Лінтинг та форматування коду

У проекті використовується ESLint для автоматичної перевірки якості коду та Prettier для його форматування. Це дозволяє підтримувати єдиний стиль написання коду, уникати помилок і підвищувати читабельність. Навіть якщо ви тільки починаєте працювати з JavaScript або TypeScript, ці інструменти допоможуть вам швидко звикнути до сучасних стандартів розробки та уникати типових помилок.

### ESLint
ESLint налаштований з урахуванням специфіки Next.js, TypeScript, React та сучасних практик розробки. Нижче наведено основні правила, які діють у проекті, з детальними поясненнями для кращого розуміння.

- **Загальні правила:**
    - **no-var / prefer-const** — Заборонено використовувати `var`, рекомендовано `const`. Змінні слід оголошувати через `const`, щоб уникати випадкової зміни їх значення. Це робить код більш передбачуваним і безпечним.
    - **eqeqeq** — Вимога суворого порівняння. Завжди використовуйте `===` та `!==` замість `==` та `!=`, щоб уникнути неочікуваних результатів при порівнянні різних типів даних. Це допомагає уникати помилок, які важко знайти.
    - **no-duplicate-imports** — Заборонено дублювання імпортів. В одному файлі не можна імпортувати один і той самий модуль кілька разів. Це зменшує плутанину та покращує читабельність коду.
    - **no-shadow** — Заборонено тіньування змінних. Не можна оголошувати змінну з таким самим ім'ям, як у зовнішньому блоці. Це допомагає уникати помилок, коли ви випадково перекриваєте значення змінної.
    - **curly** — Всі блоки повинні бути обгорнуті фігурними дужками. Навіть якщо блок містить лише один рядок, використовуйте фігурні дужки. Це робить код більш зрозумілим і зменшує ризик помилок при додаванні нових рядків.
    - **arrow-body-style** — Стрілочні функції без зайвих фігурних дужок. Якщо функція повертає значення одразу, не потрібно писати фігурні дужки та ключове слово `return`. Це робить код коротшим і легшим для читання.
    - **no-console** — Консоль дозволена лише для `warn` та `error`. Використовуйте `console.warn` та `console.error` для повідомлень про помилки або попередження, але уникайте зайвих `console.log` у робочому коді. Це допомагає підтримувати чистоту журналу та не засмічувати його зайвою інформацією.

- **TypeScript:**
    - **@typescript-eslint/no-explicit-any** — Попередження при використанні `any`. Тип `any` слід уникати, оскільки він відключає перевірку типів і може призвести до помилок у майбутньому. Якщо не знаєте точний тип, краще спробувати його визначити або використати більш конкретний тип.
    - **@typescript-eslint/no-unused-vars** — Попередження про невикористані змінні (ігноруються, якщо починаються з `_`). Якщо ви оголосили змінну, але не використовуєте її, з'явиться попередження. Це допомагає тримати код чистим, а змінні, які починаються з `_`, ігноруються, що зручно для тимчасових або службових змінних.
    - **@typescript-eslint/no-non-null-assertion** — Заборонено неявні non-null assertions (`!`). Не використовуйте оператор `!` для примусового ігнорування можливості null або undefined. Це може призвести до помилок під час виконання, якщо значення все ж таки буде null.
    - **@typescript-eslint/consistent-type-imports** — Всі імпорти типів мають бути через `import type`. Для імпорту типів використовуйте спеціальний синтаксис `import type`, щоб відокремити типи від звичайних імпортів. Це покращує читабельність і допомагає інструментам оптимізувати код.

- **React:**
    - **react/prop-types** — Вимкнено перевірку PropTypes (оскільки використовується TypeScript). Оскільки TypeScript вже забезпечує перевірку типів, додатково використовувати PropTypes не потрібно. Це спрощує код і зменшує дублювання логіки.
    - **react/jsx-no-duplicate-props** — Заборонено дублювання props у JSX. Не можна передавати один і той самий prop кілька разів одному компоненту. Це допомагає уникати неочікуваної поведінки компонентів.
    - **react/no-unescaped-entities** — Вимкнено попередження про неекрановані символи у JSX. Деякі символи, наприклад апострофи чи лапки, можна використовувати у JSX без додаткового екранування. Це робить написання тексту у компонентах простішим.
    - **react/self-closing-comp** — Вимога самозакриття компонентів без дітей. Якщо компонент не містить дочірніх елементів, його слід записувати у вигляді самозакритого тегу. Це покращує читабельність і структуру коду.
    - **react-hooks/rules-of-hooks** — Дотримання правил хуків React. Використовуйте хуки лише у функціональних компонентах та дотримуйтесь їх порядку. Це важливо для коректної роботи стану та ефектів у React.

- **Імпорти:**
    - **import/order** — Впорядкування імпортів за групами (вбудовані, зовнішні, внутрішні, відносні). Імпорти мають бути організовані у певному порядку, щоб код був структурованим і легким для навігації. Це особливо корисно у великих файлах з багатьма залежностями.
    - **import/order (react first)** — Імпорт `react` завжди перший серед зовнішніх. Це правило допомагає швидко знаходити основну бібліотеку у списку імпортів. Також це відповідає загальноприйнятим стандартам у спільноті React.
    - **import/no-unresolved, import/no-duplicates** — Заборонено невирішені та дубльовані імпорти. Всі імпорти мають бути коректними, а дублювання — відсутнє. Це зменшує кількість помилок при запуску та полегшує підтримку коду.
  - **Експорти:**
    - **export default** — Використовуємо для React компонентів, Next.js сторінок та основних модулів. Це спрощує імпорти та забезпечує стандартний підхід для компонентів. Приклад: `export default function HomePage() {}`
    - **named exports** — Використовуємо для утиліт, хуків, констант, типів та допоміжних функцій. Це дозволяє експортувати кілька елементів з одного файлу та робить імпорти більш явними. Приклад: `export const API_URLS = {}`
    - **export type** — Для TypeScript типів завжди використовуємо `export type`. Це допомагає розрізняти типи від звичайних експортів та покращує tree-shaking
    - **Не змішуємо** default та named експорти в одному файлі без вагомої причини — це може створювати плутанину

  - **Функції:**
    - **Компоненти React** — Завжди function declarations для кращої читабельності та hoisting:
    ```typescript
    function UserProfile() {
      return <div>Profile</div>;
    }
    export default UserProfile;
    ```
    
    - **Next.js сторінки та API routes** — Function declarations для консистентності:
    ```typescript
    function HomePage() {
      return <div>Home</div>;
    }
    
    export default function handler(req, res) {
      // API logic
    }
    ```
    
    - **Хуки (custom hooks)** — Arrow functions з const для явного позначення, що це функції:
    ```typescript
    const useUserProfile = () => {
      const [user, setUser] = useState(null);
      return { user, setUser };
    };
    ```
    
    - **Утилітарні функції** — Arrow functions з const для функціонального стилю:
    ```typescript
    const formatDate = (date: Date) => {
      return date.toLocaleDateString();
    };
    
    const validateEmail = (email: string) => email.includes('@');
    ```
    
    - **Константи та конфігурація** — Звичайні константи з UPPER_CASE для глобальних значень:
    ```typescript
    const API_BASE_URL = 'https://api.example.com';
    const DEFAULT_PAGINATION_SIZE = 10;
    ```
    
    - **Обробники подій** — Arrow functions для зв'язування контексту:
    ```typescript
    const handleSubmit = (e: FormEvent) => {
      e.preventDefault();
      // logic
    };
    ```

  - **Найменування файлів:**
    - **Компоненти** — PascalCase: `UserProfile.tsx`, `LoginForm.tsx`
    - **Хуки** — camelCase з префіксом "use": `useAuth.ts`, `useLocalStorage.ts`
    - **Утиліти** — camelCase: `dateUtils.ts`, `apiHelpers.ts`
    - **Типи** — camelCase: `userTypes.ts`, `apiTypes.ts`
    - **Константи** — camelCase: `apiConstants.ts`, `appConfig.ts`

- **Доступність:**
    - **jsx-a11y/alt-text** — Попередження, якщо не вказано alt-текст для зображень. Для всіх зображень необхідно вказувати опис через атрибут `alt`. Це важливо для користувачів з обмеженими можливостями та для SEO.

- **Next.js:**
    - **@next/next/no-img-element** — Заборонено використання `<img>` замість `next/image`. Для зображень у Next.js слід використовувати компонент `next/image`, який оптимізує завантаження та розмір картинок. Це підвищує продуктивність сайту та покращує досвід користувача.
    - **@next/next/no-sync-scripts, @next/next/no-html-link-for-pages** — Заборонено використання синхронних скриптів та невалідних посилань. Не використовуйте синхронні скрипти, оскільки вони можуть блокувати рендеринг сторінки. Також переконайтеся, що всі посилання ведуть на існуючі сторінки.

- **Форматування:**
    - **semi** — Вимога крапки з комою наприкінці кожного виразу. Кожен рядок коду має закінчуватися крапкою з комою, щоб уникати неочікуваних помилок при виконанні. Це правило допомагає підтримувати однаковий стиль у всіх файлах проекту.

### Prettier
Prettier відповідає за автоматичне форматування коду. Він автоматично виправляє відступи, лапки, розставляє крапки з комою та інші дрібниці, щоб код виглядав однаково у всіх учасників команди. Це особливо корисно для новачків, оскільки дозволяє не перейматися дрібними деталями оформлення коду.

- **semi** — Крапка з комою наприкінці рядків (`semi: true`). Кожен рядок завершується крапкою з комою, що допомагає уникати помилок при виконанні коду. Це правило також робить стиль коду однаковим у всіх учасників команди.
- **singleQuote** — Одинарні лапки для рядків (`singleQuote: true`). Для рядків використовуються одинарні лапки замість подвійних. Це спрощує читання коду та зменшує кількість непотрібних змін при автозаміні.
- **tabWidth** — Відступ у 4 пробіли (`tabWidth: 4`). Весь код має однаковий відступ у 4 пробіли, що робить структуру коду зрозумілою навіть для новачків. Це допомагає уникати плутанини з різними відступами у різних файлах.
- **trailingComma** — Кожен елемент у багаторядкових структурах має мати кому (`trailingComma: es5`). У багаторядкових масивах та об'єктах після останнього елемента ставиться кома. Це спрощує додавання нових елементів і зменшує кількість помилок у git diff.
- **printWidth** — Максимальна довжина рядка — 80 символів (`printWidth: 80`). Рядки коду не повинні перевищувати 80 символів, щоб їх було зручно читати навіть на невеликих екранах. Це також допомагає уникати горизонтального скролу у редакторі.
- **bracketSpacing** — Пробіли всередині дужок (`bracketSpacing: true`). Між дужками та вмістом завжди є пробіли, що робить код більш "дружнім" для читання. Це дрібниця, але вона покращує загальний вигляд коду.
- **arrowParens** — Завжди використовуються дужки для аргументів стрілочних функцій (`arrowParens: always`). Навіть якщо у стрілочної функції один аргумент, все одно використовуються дужки. Це робить код більш передбачуваним і полегшує автоматичне форматування.
- **endOfLine** — Вирівнювання рядків за допомогою символу переносу рядка LF (`endOfLine: lf`). Для переносу рядків використовується символ LF, що є стандартом для більшості сучасних систем. Це допомагає уникати проблем з відображенням коду на різних операційних системах.

> **Рекомендація:** Використовуйте автоматичне форматування при збереженні файлів у редакторі для дотримання єдиного стилю коду.
> **Рекомендація:** Використовуйте автоматичне форматування при збереженні файлів у редакторі для дотримання єдиного стилю коду. Це значно спрощує командну роботу та дозволяє зосередитися на логіці, а не на оформленні.